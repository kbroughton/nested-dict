1) Dictionaries with mixed depth of nested levels:

(Only works well for scalars)


	nd= nested_dict()                                   
	nd["mouse"]["chr1"]["+"] = 311                      
	nd["mouse"]["chromosomes"]="completed"              
	nd["mouse"]["chr2"] = "2nd longest"                             
	nd["mouse"]["chr3"] = "3rd longest"                 
	nd["human_chromosomes"] = "to be done"


2) Dictionaries with pre-determined levels of nesting, and type of the contained value:

(Especially useful for containers)

	# two levels of nesting
	nd2 = nested_dict(2, list)
	nd2["mouse"]["chr2"].append(12)
	
	# three levels of nesting
	nd3 = nested_dict(3, set)
	nd3["mouse"]["chr2"]["categorised"].add(3)
	
	# counts
	nd4 = nested_dict(2, int)
	nd4["mouse"]["chr2"]+=4
	nd4["human"]["chr1"]+=3
	nd4["human"]["chr3"]+=4

3) Dictionaries with lists or sets (or arbitrary objects) can have custom merge strategies:


	> nd1 = nested_dict({'a':1,'f':[1,3]})
	> nd2 = nested_dict({'a':1,'f':[1,2]})
	
	# use built-in strategy to merge lists
	> nd1.update(nd2, strategies=['uniquely_extend_list'])
	{'a':1,'f':[1,3,2]}
	
Here we are using the built-in strategy_options.  
If your dict contains structures you may specify which ones update() will use with the strategies kwarg (list).
You may also supply your own strategy_options kwarg (list)

	default_strategy_options=[
				  {'name': 'uniquely_extend_list', 'signature': (list,list), 
                   'combiner': lambda x,y: x + list(set(y) - set(x)) },
                  
                  {'name': 'list_of_union', 'signature': (list,list), 
                   'combiner': lambda x,y: list(set(y) + set(x)) },
                  
                  {'name': 'symmetric_difference', 'signature': (set,set),
                   'combiner': lambda x,y: x.symmetric_difference(y)},
                   ]
	